// Code generated by goctl. DO NOT EDIT.

package model

import (
	"context"
	"database/sql"
	"fmt"
	"strings"

	"github.com/zeromicro/go-zero/core/stores/builder"
	"github.com/zeromicro/go-zero/core/stores/cache"
	"github.com/zeromicro/go-zero/core/stores/sqlc"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"github.com/zeromicro/go-zero/core/stringx"
)

var (
	casbinRuleFieldNames          = builder.RawFieldNames(&CasbinRule{})
	casbinRuleRows                = strings.Join(casbinRuleFieldNames, ",")
	casbinRuleRowsExpectAutoSet   = strings.Join(stringx.Remove(casbinRuleFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), ",")
	casbinRuleRowsWithPlaceHolder = strings.Join(stringx.Remove(casbinRuleFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), "=?,") + "=?"

	cacheCasbinRuleIdPrefix                = "cache:casbinRule:id:"
	cacheCasbinRulePtypeV0V1V2V3V4V5Prefix = "cache:casbinRule:ptype:v0:v1:v2:v3:v4:v5:"
	cacheCasbinRuleV0V1V2V3V4V5Prefix      = "cache:casbinRule:v0:v1:v2:v3:v4:v5:"
)

type (
	casbinRuleModel interface {
		Insert(ctx context.Context, data *CasbinRule) (sql.Result, error)
		FindOne(ctx context.Context, id int64) (*CasbinRule, error)
		FindOneByPtypeV0V1V2V3V4V5(ctx context.Context, ptype string, v0 string, v1 string, v2 string, v3 string, v4 string, v5 string) (*CasbinRule, error)
		FindOneByV0V1V2V3V4V5(ctx context.Context, v0 string, v1 string, v2 string, v3 string, v4 string, v5 string) (*CasbinRule, error)
		Update(ctx context.Context, data *CasbinRule) error
		Delete(ctx context.Context, id int64) error
	}

	defaultCasbinRuleModel struct {
		sqlc.CachedConn
		table string
	}

	CasbinRule struct {
		Id    int64          `db:"id"`
		Ptype string `db:"ptype"`
		V0    string `db:"v0"`
		V1    string `db:"v1"`
		V2    string `db:"v2"`
		V3    string `db:"v3"`
		V4    string `db:"v4"`
		V5    string `db:"v5"`
	}
)

func newCasbinRuleModel(conn sqlx.SqlConn, c cache.CacheConf, opts ...cache.Option) *defaultCasbinRuleModel {
	return &defaultCasbinRuleModel{
		CachedConn: sqlc.NewConn(conn, c, opts...),
		table:      "`casbin_rule`",
	}
}

func (m *defaultCasbinRuleModel) withSession(session sqlx.Session) *defaultCasbinRuleModel {
	return &defaultCasbinRuleModel{
		CachedConn: m.CachedConn.WithSession(session),
		table:      "`casbin_rule`",
	}
}

func (m *defaultCasbinRuleModel) Delete(ctx context.Context, id int64) error {
	data, err := m.FindOne(ctx, id)
	if err != nil {
		return err
	}

	casbinRuleIdKey := fmt.Sprintf("%s%v", cacheCasbinRuleIdPrefix, id)
	casbinRulePtypeV0V1V2V3V4V5Key := fmt.Sprintf("%s%v:%v:%v:%v:%v:%v:%v", cacheCasbinRulePtypeV0V1V2V3V4V5Prefix, data.Ptype, data.V0, data.V1, data.V2, data.V3, data.V4, data.V5)
	casbinRuleV0V1V2V3V4V5Key := fmt.Sprintf("%s%v:%v:%v:%v:%v:%v", cacheCasbinRuleV0V1V2V3V4V5Prefix, data.V0, data.V1, data.V2, data.V3, data.V4, data.V5)
	_, err = m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("delete from %s where `id` = ?", m.table)
		return conn.ExecCtx(ctx, query, id)
	}, casbinRuleIdKey, casbinRulePtypeV0V1V2V3V4V5Key, casbinRuleV0V1V2V3V4V5Key)
	return err
}

func (m *defaultCasbinRuleModel) FindOne(ctx context.Context, id int64) (*CasbinRule, error) {
	casbinRuleIdKey := fmt.Sprintf("%s%v", cacheCasbinRuleIdPrefix, id)
	var resp CasbinRule
	err := m.QueryRowCtx(ctx, &resp, casbinRuleIdKey, func(ctx context.Context, conn sqlx.SqlConn, v any) error {
		query := fmt.Sprintf("select %s from %s where `id` = ? limit 1", casbinRuleRows, m.table)
		return conn.QueryRowCtx(ctx, v, query, id)
	})
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultCasbinRuleModel) FindOneByPtypeV0V1V2V3V4V5(ctx context.Context, ptype string, v0 string, v1 string, v2 string, v3 string, v4 string, v5 string) (*CasbinRule, error) {
	casbinRulePtypeV0V1V2V3V4V5Key := fmt.Sprintf("%s%v:%v:%v:%v:%v:%v:%v", cacheCasbinRulePtypeV0V1V2V3V4V5Prefix, ptype, v0, v1, v2, v3, v4, v5)
	var resp CasbinRule
	err := m.QueryRowIndexCtx(ctx, &resp, casbinRulePtypeV0V1V2V3V4V5Key, m.formatPrimary, func(ctx context.Context, conn sqlx.SqlConn, v any) (i any, e error) {
		query := fmt.Sprintf("select %s from %s where `ptype` = ? and `v0` = ? and `v1` = ? and `v2` = ? and `v3` = ? and `v4` = ? and `v5` = ? limit 1", casbinRuleRows, m.table)
		if err := conn.QueryRowCtx(ctx, &resp, query, ptype, v0, v1, v2, v3, v4, v5); err != nil {
			return nil, err
		}
		return resp.Id, nil
	}, m.queryPrimary)
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultCasbinRuleModel) FindOneByV0V1V2V3V4V5(ctx context.Context, v0 string, v1 string, v2 string, v3 string, v4 string, v5 string) (*CasbinRule, error) {
	casbinRuleV0V1V2V3V4V5Key := fmt.Sprintf("%s%v:%v:%v:%v:%v:%v", cacheCasbinRuleV0V1V2V3V4V5Prefix, v0, v1, v2, v3, v4, v5)
	var resp CasbinRule
	err := m.QueryRowIndexCtx(ctx, &resp, casbinRuleV0V1V2V3V4V5Key, m.formatPrimary, func(ctx context.Context, conn sqlx.SqlConn, v any) (i any, e error) {
		query := fmt.Sprintf("select %s from %s where `v0` = ? and `v1` = ? and `v2` = ? and `v3` = ? and `v4` = ? and `v5` = ? limit 1", casbinRuleRows, m.table)
		if err := conn.QueryRowCtx(ctx, &resp, query, v0, v1, v2, v3, v4, v5); err != nil {
			return nil, err
		}
		return resp.Id, nil
	}, m.queryPrimary)
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultCasbinRuleModel) Insert(ctx context.Context, data *CasbinRule) (sql.Result, error) {
	casbinRuleIdKey := fmt.Sprintf("%s%v", cacheCasbinRuleIdPrefix, data.Id)
	casbinRulePtypeV0V1V2V3V4V5Key := fmt.Sprintf("%s%v:%v:%v:%v:%v:%v:%v", cacheCasbinRulePtypeV0V1V2V3V4V5Prefix, data.Ptype, data.V0, data.V1, data.V2, data.V3, data.V4, data.V5)
	casbinRuleV0V1V2V3V4V5Key := fmt.Sprintf("%s%v:%v:%v:%v:%v:%v", cacheCasbinRuleV0V1V2V3V4V5Prefix, data.V0, data.V1, data.V2, data.V3, data.V4, data.V5)
	ret, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("insert into %s (%s) values (?, ?, ?, ?, ?, ?, ?)", m.table, casbinRuleRowsExpectAutoSet)
		return conn.ExecCtx(ctx, query, data.Ptype, data.V0, data.V1, data.V2, data.V3, data.V4, data.V5)
	}, casbinRuleIdKey, casbinRulePtypeV0V1V2V3V4V5Key, casbinRuleV0V1V2V3V4V5Key)
	return ret, err
}

func (m *defaultCasbinRuleModel) Update(ctx context.Context, newData *CasbinRule) error {
	data, err := m.FindOne(ctx, newData.Id)
	if err != nil {
		return err
	}

	casbinRuleIdKey := fmt.Sprintf("%s%v", cacheCasbinRuleIdPrefix, data.Id)
	casbinRulePtypeV0V1V2V3V4V5Key := fmt.Sprintf("%s%v:%v:%v:%v:%v:%v:%v", cacheCasbinRulePtypeV0V1V2V3V4V5Prefix, data.Ptype, data.V0, data.V1, data.V2, data.V3, data.V4, data.V5)
	casbinRuleV0V1V2V3V4V5Key := fmt.Sprintf("%s%v:%v:%v:%v:%v:%v", cacheCasbinRuleV0V1V2V3V4V5Prefix, data.V0, data.V1, data.V2, data.V3, data.V4, data.V5)
	_, err = m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("update %s set %s where `id` = ?", m.table, casbinRuleRowsWithPlaceHolder)
		return conn.ExecCtx(ctx, query, newData.Ptype, newData.V0, newData.V1, newData.V2, newData.V3, newData.V4, newData.V5, newData.Id)
	}, casbinRuleIdKey, casbinRulePtypeV0V1V2V3V4V5Key, casbinRuleV0V1V2V3V4V5Key)
	return err
}

func (m *defaultCasbinRuleModel) formatPrimary(primary any) string {
	return fmt.Sprintf("%s%v", cacheCasbinRuleIdPrefix, primary)
}

func (m *defaultCasbinRuleModel) queryPrimary(ctx context.Context, conn sqlx.SqlConn, v, primary any) error {
	query := fmt.Sprintf("select %s from %s where `id` = ? limit 1", casbinRuleRows, m.table)
	return conn.QueryRowCtx(ctx, v, query, primary)
}

func (m *defaultCasbinRuleModel) tableName() string {
	return m.table
}
